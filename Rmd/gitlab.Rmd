---
editor_options:
  chunk_output_type: console
---

# NOTES

-   The [gitlabr](https://thinkr-open.github.io/gitlabr/) package unfortunately neither conveniently supports HTTP HEAD requests, nor does it expose the API
    response's HTTP header values. Also it's built upon legacy httr. Hence, this httr2-based **gitlab** package with a thoroughly designed core `api_req()` that
    easily enables us to implement the RESTful API like it's meant to be used, including light-weight ("cached") requests etc. The package is designed in a
    fully functional way which may look unfamiliar due to the constant argument passing, especially between default arguments. This is the very spirit of
    functional programming that fosters correctness.

    Thanks to [pal's canonicalized way to package configuration](https://pal.rpkg.dev/reference/#package-configuration), setting necessary state globally like
    API's base URL and access token is still easy for users and transparent for devs.

-   "GitLab *project*" and "GitLab *repository*" are used interchageably in the documentation of this package.

# EXPORTED

## Common

### DESCRIPTION

Common functions that are of generic use.

### `api_req`

```{r}
#' Create GitLab API request
#'
#' Assembles the HTTP request structure that is common to *all* [GitLab v4 RESTful API](https://docs.gitlab.com/ee/api/rest/) requests performed by this
#' package.
#'
#' @inheritParams nocodb::api
#' @param path `r pkgsnip::type("chr", 1L)`
#'   Path relative to the GitLab API `base_url`.
#' @param method `r pkgsnip::type("chr", 1L)`
#'   `r pkgsnip::param_lbl("http_method", one_of = pal::enum_fn_param_defaults(param = "method", fn = api_req))`
#' @param base_url `r pkgsnip::type("chr", 1L)`
#'   Base URL to the GitLab v4 RESTful API root.
#' @param token `r pkgsnip::type("chr", 1L)`
#'   [GitLab access token](https://docs.gitlab.com/ee/api/rest/authentication.html) used for authentication. If `NULL`, the API request is made unauthenticated
#'   which results in *HTTP 404 Not Found* and other errors for non-public resources.
#'
#' @return httr2::req_method return
#' @family common
#' @export
#'
#' @examples
#' # let's call the `/metadata` endpoint (https://docs.gitlab.com/ee/api/metadata.html)
#' gitlab::api_req(path = "/metadata",
#'                 method = "GET") |>
#'   httr2::req_perform() |>
#'   httr2::resp_body_json()
api_req <- function(path,
                    method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                    url_params = NULL,
                    body_json = NULL,
                    auto_unbox = TRUE,
                    base_url = pal::pkg_config_val("base_url"),
                    token = pal::pkg_config_val("token"),
                    max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_list(url_params,
                         null.ok = TRUE,
                         any.missing = FALSE,
                         names = "named")
  checkmate::assert_flag(auto_unbox)
  checkmate::assert_string(base_url)
  checkmate::assert_string(token,
                           null.ok = TRUE)
  checkmate::assert_count(max_tries,
                          positive = TRUE)
  # tweak path slashes
  path %<>% stringr::str_replace(pattern = "^/+",
                                 replacement = "")
  base_url %<>% stringr::str_replace(pattern = "(/+)?$",
                                     replacement = "/")
  # convert non-chr URL param vals to JSON for convenience (`httr2::req_url_query()` just forwards everything as chr)
  url_params %<>% purrr::map_if(.p = \(x) !("AsIs" %in% class(x)) && !is.character(x),
                                .f = \(x) jsonlite::toJSON(x = x,
                                                           auto_unbox = TRUE))
  req <-
    httr2::request(base_url = paste0(base_url, path)) |>
    httr2::req_method(method = method) |>
    httr2::req_url_query(!!!url_params) |>
    httr2::req_headers(`PRIVATE-TOKEN` = token,
                       .redact = "PRIVATE-TOKEN") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) {
      
      if (httr2::resp_has_body(resp)) {
        return(httr2::resp_body_json(resp)$message)
      }
      
      NULL
    })
  
  if (length(body_json) > 0L) {
    checkmate::assert_list(body_json)
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  req
}
```

### `build_url`

NOTES:

-   See [gitlab-org/gitlab#424908](https://gitlab.com/gitlab-org/gitlab/-/issues/424908) for background about the `ref_type=heads` URL param.

```{r}
#' Build GitLab repository URL
#'
#' Assembles the URL to the specified repository path for GitLab's web interface.
#'
#' @inheritParams project
#' @inheritParams file_req
#' @param ... `r pkgsnip::type("chr")`
#'   Optional path components added to the repository base URL.
#' @param force_branch_ref `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to force `ref` to be interpreted as a *branch* name by adding the `ref_type=heads` URL parameter.
#'
#' @return A character scalar.
#' @family common
#' @export
#'
#' @examples
#' gitlab::build_url(id_project = 64767928,
#'                   "Rmd/gitlab.Rmd")
build_url <- function(id_project = pal::pkg_config_val("id_project"),
                      ...,
                      ref = NULL,
                      force_branch_ref = FALSE,
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  checkmate::assert_string(ref,
                           null.ok = TRUE)
  checkmate::assert_flag(force_branch_ref)
  
  if (is.null(ref)) {
    ref <- "HEAD"
  }
  
  project(id_project = id_project,
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    purrr::chuck("web_url") |>
    paste0(fs::path("/-/tree", ref, ..., ifelse(force_branch_ref,
                                                "?ref_type=heads",
                                                "")))
}
```

## Projects

### DESCRIPTION

Functions to manage GitLab projects.

### `project`

NOTES:

-   We do not name this fn `proj` to avoid masking `stats::proj()` when the pkg is attached.

```{r}
#' GitLab project metadata
#'
#' Retrieves a GitLab project's metadata via the [`GET /projects/{id_project}`](https://docs.gitlab.com/ee/api/projects.html#get-a-single-project) endpoint of
#' GitLab's v4 RESTful API.
#'
#' @inheritParams api_req
#' @param id_project `r pkgsnip::type("int", 1L)`
#'   GitLab project identifier.
#'
#' @return A list.
#' @family common
#' @export
#'
#' @examples
#' gitlab::project(id_project = 64767928)
project <- function(id_project = pal::pkg_config_val("id_project"),
                    base_url = pal::pkg_config_val("base_url"),
                    token = pal::pkg_config_val("token"),
                    max_tries = 3L) {
  
  checkmate::assert_int(id_project)
  
  api_req(path = glue::glue("/projects/{id_project}"),
          method = "GET",
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}
```

### `project_default_branch`

```{r}
#' GitLab project default branch
#'
#' Determines a GitLab project's default Git branch name.
#'
#' @inheritParams project
#'
#' @return A character scalar.
#' @family common
#' @export
#'
#' @examples
#' gitlab::project_default_branch(id_project = 64767928)
project_default_branch <- function(id_project = pal::pkg_config_val("id_project"),
                                   base_url = pal::pkg_config_val("base_url"),
                                   token = pal::pkg_config_val("token"),
                                   max_tries = 3L) {
  project(id_project = id_project,
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    purrr::chuck("default_branch")
}
```

## Directories

### DESCRIPTION

Functions to manage directories in GitLab projects.

### `dir_ls`

```{r}
#' List files and directories in GitLab repository
#'
#' Lists file and directory names found under the specified path in a GitLab repository via the
#' [`GET /projects/:id/repository/tree`](https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree) endpoint of GitLab's v4 RESTful API.
#'
#' @inheritParams api_req
#' @inheritParams project
#' @inheritParams file_req
#' @param path `r pkgsnip::type("chr", 1L)`
#'   Directory path, relative to the repository root.
#' @param recurse `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to recurse into subdirectories of `path`.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family dirs
#' @export
#'
#' @examples
#' gitlab::dir_ls(id_project = 64767928,
#'                path = "man",
#'                recurse = TRUE)
dir_ls <- function(path = "",
                   id_project = pal::pkg_config_val("id_project"),
                   recurse = FALSE,
                   ref = project_default_branch(id_project = id_project,
                                                base_url = base_url,
                                                token = token,
                                                max_tries = max_tries),
                   base_url = pal::pkg_config_val("base_url"),
                   token = pal::pkg_config_val("token"),
                   max_tries = 3L) {
  
  checkmate::assert_string(path)
  checkmate::assert_int(id_project)
  checkmate::assert_flag(recurse)
  checkmate::assert_string(ref)
  
  api_req(path = glue::glue("/projects/{id_project}/repository/tree"),
          method = "GET",
          url_params = list(path = path,
                            recursive = recurse,
                            ref = ref,
                            pagination = "keyset",
                            per_page = 100L),
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    # cf. https://docs.gitlab.com/ee/api/rest/index.html#keyset-based-pagination
    httr2::req_perform_iterative(next_req = httr2::iterate_with_link_url(rel = "next"),
                                 max_reqs = Inf) |>
    # convert responses to tibble
    purrr::map(\(x) {
      httr2::resp_body_json(x) |>
        purrr::map_dfr(tibble::as_tibble_row)
    }) |>
    purrr::list_rbind()
}
```

### `dir_delete`

```{r}
#' Delete directory from GitLab repository
#'
#' Deletes all files (Git blob objects) and submodule references (Git commit objects) within a directory of a GitLab repository, effectively deleting the
#' directory (Git tree object), in a single Git commit. High-level convenience function that combines [dir_ls()] and [files_delete()].
#'
#' @inheritParams dir_ls
#' @inheritParams files_delete
#'
#' @inherit files_delete return
#' @family dirs
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::dir_delete(path = "docs/dev",
#'                    id_project = 64767928)}
dir_delete <- function(path,
                       id_project = pal::pkg_config_val("id_project"),
                       start_branch = project_default_branch(id_project = id_project,
                                                             base_url = base_url,
                                                             token = token,
                                                             max_tries = max_tries),
                       start_sha = NULL,
                       start_project = NULL,
                       branch = start_branch,
                       commit_message = "auto: delete directory via gitlab R pkg",
                       author_email = NULL,
                       author_name = NULL,
                       incl_stats = TRUE,
                       force = FALSE,
                       last_commit_id = NULL,
                       base_url = pal::pkg_config_val("base_url"),
                       token = pal::pkg_config_val("token"),
                       max_tries = 3L) {
  dir_ls(path = path,
         id_project = id_project,
         recurse = TRUE,
         ref = start_branch %||% branch,
         base_url = base_url,
         token = token,
         max_tries = max_tries) |>
    dplyr::filter(type != "tree") |>
    dplyr::pull("path") |>
    files_delete(id_project = id_project,
                 start_branch = start_branch,
                 start_sha = start_sha,
                 start_project = start_project,
                 branch = branch,
                 commit_message = commit_message,
                 author_email = author_email,
                 author_name = author_name,
                 incl_stats = incl_stats,
                 force = force,
                 last_commit_id = last_commit_id,
                 base_url = base_url,
                 token = token,
                 max_tries = max_tries)
}
```

## Files

### DESCRIPTION

Functions to manage files in GitLab projects.

### !`file_req`

```{r}
#' Create GitLab file management API request
#'
#' Assembles the HTTP request structure that is common to *all* GitLab v4 RESTful API requests to manage files performed by this package.
#'
#' @inheritParams api_req
#' @inheritParams project
#' @param path `r pkgsnip::type("chr", 1L)`
#'   File path, relative to the repository root.
#' @param ref `r pkgsnip::type("chr", 1L)`
#'   [Git revision expression](https://git-scm.com/docs/revisions#_specifying_revisions) matching the desired Git tree object, e.g. a ref name (branch, tag,
#'   etc.), a commit identifier, or another symbolic reference like `"HEAD~10"`. Note that the GitLab API doesn't support every type of revision expression.
#'   Defaults to `"HEAD"` if `NULL`.
#'
#' @return httr2::req_method return
#' @family files
#' @keywords internal
#'
#' @examples
#' gitlab:::file_req(method = "HEAD",
#'                   path = "README.md",
#'                   id_project = 64767928,
#'                   ref = "HEAD")
file_req <- function(method,
                     path,
                     id_project = pal::pkg_config_val("id_project"),
                     ref = NULL,
                     body_json = NULL,
                     base_url = pal::pkg_config_val("base_url"),
                     token = pal::pkg_config_val("token"),
                     max_tries = 3L) {
  
  checkmate::assert_string(path)
  checkmate::assert_int(id_project)
  checkmate::assert_string(ref,
                           null.ok = TRUE)
  
  api_req(path = glue::glue("/projects/{id_project}/repository/files/", utils::URLencode(path, reserved = TRUE)),
          method = method,
          url_params = purrr::compact(list(ref = ref)),
          body_json = body_json,
          base_url = base_url,
          token = token,
          max_tries = max_tries)
}
```

### `file_meta`

```{r}
#' GitLab file metadata
#'
#' Retrieves a file's metadata via the
#' [`HEAD /projects/{id_project}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#get-file-metadata-only-1) endpoint of GitLab's v4
#' RESTful API.
#'
#' @inheritParams file_req
#' @param attribute `r pkgsnip::type("chr", 1L)`
#'   Name of the metadata attribute to return.
#'
#' @return An integer scalar if `attribute = size`, a logical scalar if `attribute = execute_filemode`, or a character scalar in all other cases.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_meta(path = "README.md",
#'                   attribute = "execute_filemode",
#'                   id_project = 64767928)
file_meta <- function(path,
                      attribute = c("file_name",
                                    "file_path",
                                    "size",
                                    "encoding",
                                    "content_sha256",
                                    "ref",
                                    "blob_id",
                                    "commit_id",
                                    "last_commit_id",
                                    "execute_filemode"),
                      id_project = pal::pkg_config_val("id_project"),
                      ref = "HEAD",
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  attribute <- rlang::arg_match(attribute)
  
  result <- tryCatch(expr = httr2::req_perform(req = file_req(method = "HEAD",
                                                              path = path,
                                                              id_project = id_project,
                                                              ref = ref,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries)),
                     httr2_http_404 = \(cnd) NULL)
  
  if (!is.null(result)) {
    result %<>% httr2::resp_header(header = paste0("X-Gitlab-", heck::to_train_case(attribute)))
  }
  
  switch(EXPR = attribute,
         size = as.integer(result),
         execute_filemode = as.logical(result),
         result)
}
```

### `file_content`

TODO:

-   Implement pkgpins-based caching like `fokus::read_private_file()` has. In contrast to `httr2::req_cache()`, this allows to cache based on the
    `X-Gitlab-Content-Sha256` header instead of just `Etag` (which changes after every commit, regardless of actual content changes). Even better would be to
    add a `header` param to `httr2::req_cache()` to allow choosing the HTTP header name(s) to consider.

```{r}
#' Read in file from GitLab repository
#'
#' Downloads a file from a GitLab repository via the
#' [`GET /projects/{id_project}/repository/files/{path}/raw`](https://docs.gitlab.com/ee/api/repository_files.html#get-raw-file-from-repository) endpoint of
#' GitLab's v4 RESTful API and returns its content.
#'
#' @inheritParams file_req
#'
#' @return A character scalar if `path` refers to a text file, otherwise a raw vector.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_content(path = "DESCRIPTION",
#'                      id_project = 64767928) |>
#'   cat()
file_content <- function(path,
                         id_project = pal::pkg_config_val("id_project"),
                         ref = NULL,
                         base_url = pal::pkg_config_val("base_url"),
                         token = pal::pkg_config_val("token"),
                         max_tries = 3L) {
  result <-
    file_req(method = "GET",
             path = path,
             id_project = id_project,
             ref = ref,
             base_url = base_url,
             token = token,
             max_tries = max_tries) |>
    httr2::req_url_path_append("raw") |>
    httr2::req_perform()
  
  if (httr2::resp_content_type(result) == "text/plain") {
    result %<>% httr2::resp_body_string()
  } else {
    result %<>% httr2::resp_body_raw()
  }
  
  result
}
```

### `file_full`

NOTES:

-   We do not name this fn `file` to avoid masking `base::file()` when the pkg is attached.

```{r}
#' GitLab file data
#'
#' Retrieves a file's metadata and content as structured data via the
#' [`GET /projects/{id_project}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository) endpoint of GitLab's v4
#' RESTful API.
#'
#' Note that it is more efficient to use
#' - [file_content()] to only retrieve a file's content.
#' - [file_meta()] to only retrieve a single metadata entry.
#'
#' @inheritParams file_req
#'
#' @return A list.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_full(path = "DESCRIPTION",
#'                   id_project = 64767928)
file_full <- function(path,
                      id_project = pal::pkg_config_val("id_project"),
                      ref = "HEAD",
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  file_req(method = "GET",
           path = path,
           id_project = id_project,
           ref = ref,
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}
```

### `file_write`

```{r}
#' Write file to GitLab repository
#'
#' Uploads a file to a GitLab repository via [GitLab's v4 RESTful API](https://docs.gitlab.com/ee/api/rest/). High-level function that by default skips
#' uploading identical file content and automatically choses [file_create()] or [file_update()] based on whether the file already exists or not.
#'
#' To save up to two additional `HEAD` requests, set `start_branch` and `last_commit_id` explicitly. Setting `last_commit_id = NULL` is fine as long as file
#' writes are part of a controlled, single-user process where concurrency is not a concern.
#'
#' @inheritParams file_req
#' @param content `r pkgsnip::type("chr", length = 1L, add_cr = FALSE)` or `r pkgsnip::type("raw")`
#'   File content, as a character scalar for text files, or a raw vector for binary files. Or the path to a local file as a character scalar if
#'   `from_file = TRUE`.
#' @param start_branch `r pkgsnip::type("chr", 1L)`
#'   Name of the base branch to create `branch` from if it doesn't already exist.
#' @param branch `r pkgsnip::type("chr", 1L)`
#'   Git branch name to upload the file to.
#' @param from_file `r pkgsnip::type("lgl", 1L)`
#'   Whether or not `content` indicates the path to a local file instead of the actual file content.
#' @param overwrite `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to overwrite an already existing file. Unless `force = TRUE`, the file is only overwritten if it is not identical to `content`.
#' @param force `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to overwrite an already existing file even if it is identical to `content`.
#' @param commit_message `r pkgsnip::type("chr", 1L)`
#'   Git commit message.
#' @param author_email `r pkgsnip::type("chr", 1L)`
#'   Git commit author's email address. `NULL` means to default to the `token` owner.
#' @param author_name `r pkgsnip::type("chr", 1L)`
#'   Git commit author's name. `NULL` means to default to the `token` owner.
#' @param execute_filemode `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to mark the uploaded file as executable.
#' @param last_commit_id `r pkgsnip::type("chr", 1L)`
#'   Last known file commit identifier. If provided (and valid), GitLab won't write to the file if a commit made after `last_commit_id` has modified the file.
#'   Intended to avoid concurrency issues (e.g. from CI pipelines). `NULL` means to skip the check.
#' @param quiet `r pkgsnip::type("lgl", 1L)`
#'   `r pkgsnip::param_lbl("quiet")`
#'
#' @return `path`, invisibly.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_write(content = "a line of text",
#'                    path = "test.md",
#'                    id_project = 64767928)}
file_write <- function(content,
                       path,
                       id_project = pal::pkg_config_val("id_project"),
                       start_branch = project_default_branch(id_project = id_project,
                                                             base_url = base_url,
                                                             token = token,
                                                             max_tries = max_tries),
                       branch = start_branch,
                       from_file = FALSE,
                       overwrite = TRUE,
                       force = FALSE,
                       commit_message = "auto: write file via gitlab R pkg",
                       author_email = NULL,
                       author_name = NULL,
                       execute_filemode = FALSE,
                       last_commit_id = file_meta(path = path,
                                                  attribute = "last_commit_id",
                                                  id_project = id_project,
                                                  ref = branch,
                                                  base_url = base_url,
                                                  token = token,
                                                  max_tries = max_tries),
                       base_url = pal::pkg_config_val("base_url"),
                       token = pal::pkg_config_val("token"),
                       max_tries = 3L,
                       quiet = FALSE) {
  
  checkmate::assert_flag(from_file)
  checkmate::assert_flag(overwrite)
  checkmate::assert_flag(force)
  checkmate::assert_flag(quiet)
  
  if (force && !overwrite) {
    cli::cli_abort("{.arg overwrite} cannot be {.val FALSE} when {.arg force} is {.val TRUE}.")
  }
  
  is_raw <- is.raw(content)
  
  if (is_raw && from_file) {
    cli::cli_abort("{.arg content} must be a character scalar path when {.arg from_file} is {.val {from_file}}.")
  }
  if (!is_raw) {
    checkmate::assert_string(content)
  }
  
  # return early if file hasn't changed ----
  exists_file <- file_exists(path = path,
                             id_project = id_project,
                             ref = branch,
                             base_url = base_url,
                             token = token,
                             max_tries = max_tries)
  if (!force && exists_file) {
    hash_new <- ifelse(from_file,
                       digest::digest(algo = "sha256",
                                      file = content),
                       digest::digest(algo = "sha256",
                                      object = content,
                                      serialize = FALSE))
    if (!force && identical(hash_new,
                            file_meta(path = path,
                                      attribute = "content_sha256",
                                      id_project = id_project,
                                      ref = branch,
                                      base_url = base_url,
                                      token = token,
                                      max_tries = max_tries))) {
      if (!quiet) {
        cli::cli_alert_info(paste0("The new file contents are identical to the existing file contents and thus no data was uploaded to the GitLab repository. ",
                                   "Use {.code force = TRUE} to overwrite the file anyway."))
      }
      return(invisible(path))
    }
  }
  
  # read content and set encoding ----
  if (from_file) {
    content %<>% brio::read_file_raw()
    is_raw <- TRUE
  }
  
  if (is_raw) {
    content %<>% base64enc::base64encode()
    encoding <- "base64"
  } else {
    encoding <- "text"
  }
  
  # upload file ----
  if (!quiet) {
    link <- build_url(id_project = id_project,
                      path,
                      ref = branch,
                      force_branch_ref = TRUE,
                      base_url = base_url,
                      token = token,
                      max_tries = max_tries)
    cli_id <- pal::cli_progress_step_quick(msg = paste0("Uploading file to GitLab project {.val {id_project}} under path {.href [{path}]({link})}."))
  }
  
  if (exists_file) {
    if (overwrite) {
      file_update(content = content,
                  path = path,
                  id_project = id_project,
                  branch = branch,
                  commit_message = commit_message,
                  author_email = author_email,
                  author_name = author_name,
                  encoding = encoding,
                  execute_filemode = execute_filemode,
                  last_commit_id = last_commit_id,
                  start_branch = start_branch,
                  base_url = base_url,
                  token = token,
                  max_tries = max_tries)
    } else {
      link <- build_url(id_project = id_project,
                        path,
                        ref = branch,
                        force_branch_ref = TRUE,
                        base_url = base_url,
                        token = token,
                        max_tries = max_tries)
      cli::cli_alert_info(text = "File {.href [{path}]({link})} already exists on GitLab. Set {.code overwrite = TRUE} in order to overwrite it.")
    }
  } else {
    file_create(content = content,
                path = path,
                id_project = id_project,
                branch = branch,
                commit_message = commit_message,
                author_email = author_email,
                author_name = author_name,
                encoding = encoding,
                execute_filemode = execute_filemode,
                start_branch = start_branch,
                base_url = base_url,
                token = token,
                max_tries = max_tries)
  }
  
  if (!quiet) {
    cli::cli_progress_done(id = cli_id)
  }
  
  invisible(path)
}
```

### `file_create`

```{r}
#' Create file in GitLab repository
#'
#' Creates a new file in a GitLab repository via the
#' [`POST /projects/{id_project}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository) endpoint of GitLab's
#' v4 RESTful API.
#'
#' @inheritParams file_update
#'
#' @return A list with metadata about the newly created file.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_create(content = "a line of text",
#'                     path = "test.md",
#'                     id_project = 64767928)}
file_create <- function(content,
                        path,
                        id_project = pal::pkg_config_val("id_project"),
                        start_branch = project_default_branch(id_project = id_project,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: create file via gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        encoding = c("text", "base64"),
                        execute_filemode = FALSE,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(content)
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  encoding <- rlang::arg_match(encoding)
  checkmate::assert_flag(execute_filemode)
  
  file_req(method = "POST",
           path = path,
           id_project = id_project,
           body_json = purrr::compact(list(branch = branch,
                                           content = content,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           encoding = encoding,
                                           execute_filemode = execute_filemode,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}
```

### `file_update`

```{r}
#' Update file in GitLab repository
#'
#' Updates an existing file in a GitLab repository via the
#' [`PUT /projects/{id_project}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository) endpoint of
#' GitLab's v4 RESTful API.
#'
#' @inheritParams file_write
#' @param encoding `r pkgsnip::type("chr", 1L)`
#'   File encoding. One of `r pal::enum_fn_param_defaults(param = "encoding", fn = file_update)`.
#'
#' @inherit file_create return
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_update(content = "a different line of text",
#'                     path = "test.md",
#'                     id_project = 64767928)}
file_update <- function(content,
                        path,
                        id_project = pal::pkg_config_val("id_project"),
                        start_branch = project_default_branch(id_project = id_project,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: update file gitlab gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        encoding = c("text", "base64"),
                        execute_filemode = FALSE,
                        last_commit_id = NULL,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(content)
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  encoding <- rlang::arg_match(encoding)
  checkmate::assert_flag(execute_filemode)
  checkmate::assert_string(last_commit_id,
                           null.ok = TRUE)
  
  file_req(method = "PUT",
           path = path,
           id_project = id_project,
           body_json = purrr::compact(list(branch = branch,
                                           content = content,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           encoding = encoding,
                                           execute_filemode = execute_filemode,
                                           last_commit_id = last_commit_id,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}
```

### `file_delete`

```{r}
#' Delete file from GitLab repository
#'
#' Deletes a file from a GitLab repository via the
#' [`DELETE /projects/{id_project}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#delete-existing-file-in-repository) endpoint of
#' GitLab's v4 RESTful API.
#'
#' @inheritParams file_write
#'
#' @return `path`, invisibly.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_delete(path = "test.md",
#'                     id_project = 64767928)}
file_delete <- function(path,
                        id_project = pal::pkg_config_val("id_project"),
                        start_branch = project_default_branch(id_project = id_project,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: delete file via gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        last_commit_id = NULL,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  checkmate::assert_string(last_commit_id,
                           null.ok = TRUE)
  
  file_req(method = "DELETE",
           path = path,
           id_project = id_project,
           body_json = purrr::compact(list(branch = branch,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform()
  
  invisible(path)
}
```

### `files_delete`

```{r}
#' Delete multiple files from GitLab repository
#'
#' Deletes multiple files from a GitLab repository in a single Git commit. High-level convenience function that combines [file_commit_action()] and
#' [commit_files()].
#'
#' @inheritParams file_commit_action
#' @inheritParams commit_files
#' @param paths `r pkgsnip::type("chr")`
#'   File paths, relative to the repository root.
#'
#' @inherit commit_files return
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::files_delete(paths = c("test.md", "test_old.md"),
#'                      id_project = 64767928)}
files_delete <- function(paths,
                         id_project = pal::pkg_config_val("id_project"),
                         start_branch = project_default_branch(id_project = id_project,
                                                               base_url = base_url,
                                                               token = token,
                                                               max_tries = max_tries),
                         start_sha = NULL,
                         start_project = NULL,
                         branch = start_branch,
                         commit_message = "auto: delete files via gitlab R pkg",
                         author_email = NULL,
                         author_name = NULL,
                         incl_stats = TRUE,
                         force = FALSE,
                         last_commit_id = NULL,
                         base_url = pal::pkg_config_val("base_url"),
                         token = pal::pkg_config_val("token"),
                         max_tries = 3L) {
  paths |>
    purrr::map(\(path) file_commit_action(path = path,
                                          action = "delete",
                                          last_commit_id = last_commit_id)) |>
    purrr::list_rbind() |>
    commit_files(id_project = id_project,
                 start_branch = start_branch,
                 start_sha = start_sha,
                 start_project = start_project,
                 branch = branch,
                 author_email = author_email,
                 author_name = author_name,
                 incl_stats = incl_stats,
                 force = force,
                 base_url = base_url,
                 token = token,
                 max_tries = max_tries)
}
```

### `file_exists`

```{r}
#' Test if file exists in GitLab repository
#'
#' Tests whether or not a file exists in a GitLab repository.
#' 
#' `file_exists()` makes a light-weight HTTP HEAD request only and properly handles HTTP 404 Not Found errors.
#'
#' @inheritParams file_req
#'
#' @return A logical scalar.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_exists(path = "README.md",
#'                     id_project = 64767928)
#'
#' gitlab::file_exists(path = "test.md",
#'                     id_project = 64767928)
file_exists <- function(path,
                        id_project = pal::pkg_config_val("id_project"),
                        ref = "HEAD",
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  result <- tryCatch(expr = httr2::req_perform(req = file_req(method = "HEAD",
                                                              path = path,
                                                              id_project = id_project,
                                                              ref = ref,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries)),
                     httr2_http_404 = \(cnd) FALSE)
  
  if (!isFALSE(result)) {
    result <- TRUE
  }
  
  result
}
```

## Commits

### `commit_files`

```{r}
#' Create a commit with multiple file actions
#'
#' Creates a Git commit with multiple file actions including
#' `r pal::fn_param_defaults(param = "action", fn = file_commit_action) |> pal::enum_str(wrap = "\x60")` via the
#' [`POST /projects/{id_project}/repository/commits`](https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions) endpoint of
#' GitLab's v4 RESTful API.
#'
#' See the [official API documentation](https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions) for details about `actions`
#' columns and their meaning.
#'
#' @inheritParams file_write
#' @param actions `r pkgsnip::type("df")`
#'   Commit actions data as returned by [file_commit_action()]. A data frame with the columns `r colnames(ptype_file_commit_actions) |> pal::enum_str()` (the
#'   first two columns are mandatory).
#' @param start_sha `r pkgsnip::type("chr", 1L)`
#'   SHA value of the commit to create `branch` from. Alternative to `start_branch`.
#' @param start_project `r pkgsnip::type("chr", 1L)`
#'   GitLab project ID or [URL-encoded path](https://docs.gitlab.com/ee/api/rest/index.html#namespaced-paths) of the project to start the new branch from.
#'   Defaults to the value of id.
#' @param incl_stats `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to include commit statistics in the result.
#' @param force `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to overwrite `branch` with a new commit based on `start_branch` or `start_sha`. Equivalent of `git push --force`.
#'
#' @return A list with metadata about the created commit.
#' @family commits
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' list(gitlab::file_commit_action(path = "test.txt",
#'                                 action = "create",
#'                                 content = "anyone there?"),
#'      gitlab::file_commit_action(path = "old_test.txt",
#'                                 action = "delete")) |>
#'   purrr::list_rbind() |>
#'   commit_files(id_project = 64767928)}
commit_files <- function(actions,
                         id_project = pal::pkg_config_val("id_project"),
                         start_branch = project_default_branch(id_project = id_project,
                                                               base_url = base_url,
                                                               token = token,
                                                               max_tries = max_tries),
                         start_sha = NULL,
                         start_project = NULL,
                         branch = start_branch,
                         commit_message = "auto: modify files via gitlab R pkg",
                         author_email = NULL,
                         author_name = NULL,
                         incl_stats = TRUE,
                         force = FALSE,
                         base_url = pal::pkg_config_val("base_url"),
                         token = pal::pkg_config_val("token"),
                         max_tries = 3L) {
  
  checkmate::test_data_frame(actions,
                             types = unique(purrr::map_chr(ptype_file_commit_actions,
                                                           typeof)),
                             all.missing = FALSE,
                             min.cols = 2L,
                             min.rows = 1L)
  purrr::walk(colnames(actions),
              \(x) checkmate::assert_choice(x,
                                            choices = colnames(ptype_file_commit_actions),
                                            .var.name = "colnames(actions)"))
  checkmate::assert_int(id_project)
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(start_sha,
                           null.ok = TRUE)
  checkmate::assert_string(start_project,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  checkmate::assert_flag(incl_stats)
  checkmate::assert_flag(force)
  
  if (!is.null(start_branch) && !is.null(start_sha)) {
    cli::cli_abort("Only one of {.arg start_branch} or {.arg start_sha} can be set, not both.")
  }
  
  api_req(path = glue::glue("/projects/{id_project}/repository/commits"),
          method = "POST",
          body_json = purrr::compact(list(actions = actions,
                                          commit_message = commit_message,
                                          author_email = author_email,
                                          author_name = author_name,
                                          branch = branch,
                                          start_branch = start_branch,
                                          start_sha = start_sha,
                                          start_project = start_project,
                                          stats = incl_stats,
                                          force = force)),
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}
```

### `file_commit_action`

```{r}
#' Assemble file commit action
#'
#' Creates an `actions` data row ready to be fed to [commit_files()].
#'
#' @inheritParams file_write
#' @param path `r pkgsnip::type("chr", 1L)`
#'   Path to the file being acted on, relative to the repository root. For `action = "move"`, this is the destination path to move the file to.
#' @param action `r pkgsnip::type("chr", 1L)`
#'   Action to take on the file. One of `r pal::enum_fn_param_defaults(param = "action", fn = file_commit_action)`.
#' @param content `r pkgsnip::type("chr", length = 1L, add_cr = FALSE)` or `r pkgsnip::type("raw")`
#'   File content, as a character scalar for text files, or a raw vector for binary files. Or the path to a local file as a character scalar if
#'   `from_file = TRUE`. Only considered for `"create"` and `"update"` `action`s.
#' @param previous_path `r pkgsnip::type("chr", 1L)`
#'   Original path to the file being moved. Only considered for `action = "move"`.
#' @param execute_filemode `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to mark the uploaded file as executable.
#' @param last_commit_id `r pkgsnip::type("chr", 1L)`
#'   Last known file commit identifier. If provided (and valid), GitLab will only proceed if no commit made after `last_commit_id` has modified the file.
#'   Intended to avoid concurrency issues (e.g. from CI pipelines). `NULL` means to skip the check. Only considered for `"delete"`, `"move"` and `"update"`
#'   `action`s.
#'
#' @return A [tibble][tibble::tbl_df] row with the columns `r colnames(ptype_file_commit_actions) |> pal::enum_str(wrap = "\x60")`.
#' @family commits
#' @family files
#' @export
#'
#' @examples
#' # totally silly sequence of file actions to commit
#' list(gitlab::file_commit_action(path = "test.txt",
#'                                 action = "create",
#'                                 content = "anyone there?"),
#'      gitlab::file_commit_action(path = "test.txt",
#'                                 action = "update",
#'                                 content = "#!/bin/sh\n\necho 'anyone there?'\n"),
#'      gitlab::file_commit_action(path = "test.sh",
#'                                 action = "move",
#'                                 previous_path = "test.txt"),
#'      gitlab::file_commit_action(path = "test.sh",
#'                                 action = "chmod",
#'                                 execute_filemode = TRUE),
#'      gitlab::file_commit_action(path = "test.sh",
#'                                 action = "delete")) |>
#'   purrr::list_rbind()
#' 
#' # to create/update a file on GitLab with a local file's content
#' \dontrun{
#' gitlab::file_commit_action(path = "test.txt",
#'                            action = "create",
#'                            content = "/PATH/TO/LOCAL/FILE",
#'                            from_file = TRUE)}
file_commit_action <- function(path,
                               action = c("create", "delete", "move", "update", "chmod"),
                               content = NULL,
                               from_file = FALSE,
                               previous_path = NULL,
                               execute_filemode = NULL,
                               last_commit_id = NULL) {
  
  checkmate::assert_character(path)
  action <- rlang::arg_match(action)
  checkmate::assert_vector(content,
                           strict = TRUE,
                           any.missing = FALSE,
                           null.ok = !(action %in% c("create", "update")))
  checkmate::assert_flag(from_file)
  checkmate::assert_character(previous_path,
                              null.ok = action != "move")
  checkmate::assert_flag(execute_filemode,
                         null.ok = action != "chmod")
  checkmate::assert_string(last_commit_id,
                           null.ok = TRUE)
  
  # read content and set encoding ----
  encoding <- NULL
  
  if (!is.null(content)) {
    is_raw <- is.raw(content)
    
    if (is_raw && from_file) {
      cli::cli_abort("{.arg content} must be a character scalar path when {.arg from_file} is {.val {from_file}}.")
    }
    if (!is_raw) {
      checkmate::assert_string(content)
    }
    
    if (from_file) {
      content %<>% brio::read_file_raw()
      is_raw <- TRUE
    }
    
    if (is_raw) {
      content %<>% base64enc::base64encode()
      encoding <- "base64"
    } else {
      encoding <- "text"
    }
  }
  
  # create df row ----
  tibble::tibble_row(file_path = path,
                     action = action,
                     previous_path = previous_path,
                     content = content,
                     encoding = encoding,
                     execute_filemode = execute_filemode,
                     last_commit_id = last_commit_id)
}
```

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "type"))
```

## Constants

```{r}
ptype_file_commit_actions <- tibble::tibble(action = character(),
                                            file_path = character(),
                                            previous_path = character(),
                                            content = character(),
                                            encoding = character(),
                                            last_commit_id = character(),
                                            execute_filemode = logical())
```
