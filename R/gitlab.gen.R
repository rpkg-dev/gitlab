# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/gitlab.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# gitlab: Use GitLab's v4 RESTful API
# Copyright (C) 2024 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

#' Create GitLab API request
#'
#' Assembles the HTTP request structure that is common to *all* [GitLab v4 RESTful API](https://docs.gitlab.com/ee/api/rest/) requests performed by this
#' package.
#'
#' @inheritParams nocodb::api
#' @param path `r pkgsnip::type("chr", 1L)`
#'   Path relative to the GitLab API `base_url`.
#' @param method `r pkgsnip::type("chr", 1L)`
#'   `r pkgsnip::param_lbl("http_method", one_of = pal::enum_fn_param_defaults(param = "method", fn = api_req))`
#' @param base_url `r pkgsnip::type("chr", 1L)`
#'   Base URL to the GitLab v4 RESTful API root.
#' @param token `r pkgsnip::type("chr", 1L)`
#'   [GitLab access token](https://docs.gitlab.com/ee/api/rest/authentication.html) used for authentication. If `NULL`, the API request is made unauthenticated
#'   which results in *HTTP 404 Not Found* and other errors for non-public resources.
#'
#' @return httr2::req_method return
#' @family common
#' @export
#'
#' @examples
#' # let's call the `/metadata` endpoint (https://docs.gitlab.com/ee/api/metadata.html)
#' gitlab::api_req(path = "/metadata",
#'                 method = "GET") |>
#'   httr2::req_perform() |>
#'   httr2::resp_body_json()
api_req <- function(path,
                    method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                    url_params = NULL,
                    body_json = NULL,
                    auto_unbox = TRUE,
                    base_url = pal::pkg_config_val("base_url"),
                    token = pal::pkg_config_val("token"),
                    max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_list(url_params,
                         null.ok = TRUE,
                         any.missing = FALSE,
                         names = "named")
  checkmate::assert_flag(auto_unbox)
  checkmate::assert_string(base_url)
  checkmate::assert_string(token,
                           null.ok = TRUE)
  checkmate::assert_count(max_tries,
                          positive = TRUE)
  # tweak path slashes
  path %<>% stringr::str_replace(pattern = "^/+",
                                 replacement = "")
  base_url %<>% stringr::str_replace(pattern = "(/+)?$",
                                     replacement = "/")
  # convert non-chr URL param vals to JSON for convenience (`httr2::req_url_query()` just forwards everything as chr)
  url_params %<>% purrr::map_if(.p = \(x) !("AsIs" %in% class(x)) && !is.character(x),
                                .f = \(x) jsonlite::toJSON(x = x,
                                                           auto_unbox = TRUE))
  req <-
    httr2::request(base_url = paste0(base_url, path)) |>
    httr2::req_method(method = method) |>
    httr2::req_url_query(!!!url_params) |>
    httr2::req_headers(`PRIVATE-TOKEN` = token,
                       .redact = "PRIVATE-TOKEN") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) {
      
      if (httr2::resp_has_body(resp)) {
        return(httr2::resp_body_json(resp)$message)
      }
      
      NULL
    })
  
  if (length(body_json) > 0L) {
    checkmate::assert_list(body_json)
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  req
}

#' Build GitLab repository URL
#'
#' Assembles the URL to the specified repository path for GitLab's web interface.
#'
#' @inheritParams project
#' @inheritParams file_req
#' @param ... `r pkgsnip::type("chr")`
#'   Optional path components added to the repository base URL.
#' @param force_branch_ref `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to force `ref` to be interpreted as a *branch* name by adding the `ref_type=heads` URL parameter.
#'
#' @return A character scalar.
#' @family common
#' @export
#'
#' @examples
#' gitlab::build_url(id_proj = 64767928,
#'                   "Rmd/gitlab.Rmd")
build_url <- function(id_proj,
                      ...,
                      ref = NULL,
                      force_branch_ref = FALSE,
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  checkmate::assert_string(ref,
                           null.ok = TRUE)
  checkmate::assert_flag(force_branch_ref)
  
  if (is.null(ref)) {
    ref <- "HEAD"
  }
  
  project(id_proj = id_proj,
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    purrr::chuck("web_url") |>
    paste0(fs::path("/-/tree", ref, ..., ifelse(force_branch_ref,
                                                "?ref_type=heads",
                                                "")))
}

#' GitLab project metadata
#'
#' Retrieves a GitLab project's metadata via the [`GET /projects/{id_proj}`](https://docs.gitlab.com/ee/api/projects.html#get-a-single-project) endpoint of
#' GitLab's v4 RESTful API.
#'
#' @inheritParams api_req
#' @param id_proj `r pkgsnip::type("int", 1L)`
#'   GitLab project identifier.
#'
#' @return A list.
#' @family common
#' @export
#'
#' @examples
#' gitlab::project(id_proj = 64767928)
project <- function(id_proj,
                    base_url = pal::pkg_config_val("base_url"),
                    token = pal::pkg_config_val("token"),
                    max_tries = 3L) {
  
  api_req(path = glue::glue("/projects/{id_proj}"),
          method = "GET",
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}

#' GitLab project default branch
#'
#' Determines a GitLab project's default Git branch name.
#'
#' @inheritParams project
#'
#' @return A character scalar.
#' @family common
#' @export
#'
#' @examples
#' gitlab::project_default_branch(id_proj = 64767928)
project_default_branch <- function(id_proj,
                                   base_url = pal::pkg_config_val("base_url"),
                                   token = pal::pkg_config_val("token"),
                                   max_tries = 3L) {
  project(id_proj = id_proj,
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    purrr::chuck("default_branch")
}

#' List files and directories in GitLab repository
#'
#' Lists file and directory names found under the specified path in a GitLab repository via the
#' [`GET /projects/:id/repository/tree`](https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree) endpoint of GitLab's v4 RESTful API.
#'
#' @inheritParams api_req
#' @inheritParams project
#' @inheritParams file_req
#' @param path `r pkgsnip::type("chr", 1L)`
#'   Directory path, relative to the repository root.
#' @param recursive `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to recurse into subdirectories of `path`.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family dirs
#' @export
#'
#' @examples
#' gitlab::dir_ls(id_proj = 64767928,
#'                path = "man",
#'                recursive = TRUE)
dir_ls <- function(id_proj,
                   path = "",
                   recursive = FALSE,
                   ref = project_default_branch(id_proj = id_proj,
                                                base_url = base_url,
                                                token = token,
                                                max_tries = max_tries),
                   base_url = pal::pkg_config_val("base_url"),
                   token = pal::pkg_config_val("token"),
                   max_tries = 3L) {
  
  checkmate::assert_string(path)
  checkmate::assert_flag(recursive)
  checkmate::assert_string(ref)
  
  api_req(path = glue::glue("/projects/{id_proj}/repository/tree"),
          method = "GET",
          url_params = list(path = path,
                            recursive = recursive,
                            ref = ref,
                            pagination = "keyset",
                            per_page = 100L),
          base_url = base_url,
          token = token,
          max_tries = max_tries) |>
    # cf. https://docs.gitlab.com/ee/api/rest/index.html#keyset-based-pagination
    httr2::req_perform_iterative(next_req = httr2::iterate_with_link_url(rel = "next"),
                                 max_reqs = Inf) |>
    # convert responses to tibble
    purrr::map(\(x) {
      httr2::resp_body_json(x) |>
        purrr::map_dfr(tibble::as_tibble_row)
    }) |>
    purrr::list_rbind()
}

#' Create GitLab file management API request
#'
#' Assembles the HTTP request structure that is common to *all* GitLab v4 RESTful API requests to manage files performed by this package.
#'
#' @inheritParams api_req
#' @inheritParams project
#' @param path `r pkgsnip::type("chr", 1L)`
#'   File path, relative to the repository root.
#' @param ref `r pkgsnip::type("chr", 1L)`
#'   [Git revision expression](https://git-scm.com/docs/revisions#_specifying_revisions) matching the desired Git tree object, e.g. a ref name (branch, tag,
#'   etc.), a commit identifier, or another symbolic reference like `"HEAD~10"`. Note that the GitLab API doesn't support every type of revision expression.
#'   Defaults to `"HEAD"` if `NULL`.
#'
#' @return httr2::req_method return
#' @family files
#' @keywords internal
#'
#' @examples
#' gitlab::file_req(method = "HEAD",
#'                  path = "README.md",
#'                  id_proj = 64767928)
file_req <- function(method,
                     path,
                     id_proj,
                     ref = NULL,
                     body_json = NULL,
                     base_url = pal::pkg_config_val("base_url"),
                     token = pal::pkg_config_val("token"),
                     max_tries = 3L) {
  
  checkmate::assert_string(path)
  checkmate::assert_int(id_proj)
  checkmate::assert_string(ref,
                           null.ok = TRUE)
  
  api_req(path = glue::glue("/projects/{id_proj}/repository/files/", utils::URLencode(path, reserved = TRUE)),
          method = method,
          url_params = purrr::compact(list(ref = ref)),
          body_json = body_json,
          base_url = base_url,
          token = token,
          max_tries = max_tries)
}

#' GitLab file metadata
#'
#' Retrieves a file's metadata via the
#' [`HEAD /projects/{id}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#get-file-metadata-only-1) endpoint of GitLab's v4
#' RESTful API.
#'
#' @inheritParams file_req
#' @param attribute `r pkgsnip::type("chr", 1L)`
#'   Name of the metadata attribute to return.
#'
#' @return An integer scalar if `attribute = size`, a logical scalar if `attribute = execute_filemode`, or a character scalar in all other cases.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_meta(path = "README.md",
#'                   attribute = "execute_filemode",
#'                   id_proj = 64767928)
file_meta <- function(path,
                      attribute = c("file_name",
                                    "file_path",
                                    "size",
                                    "encoding",
                                    "content_sha256",
                                    "ref",
                                    "blob_id",
                                    "commit_id",
                                    "last_commit_id",
                                    "execute_filemode"),
                      id_proj,
                      ref = NULL,
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  attribute <- rlang::arg_match(attribute)
  
  result <- tryCatch(expr = httr2::req_perform(req = file_req(method = "HEAD",
                                                              path = path,
                                                              id_proj = id_proj,
                                                              ref = ref,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries)),
                     httr2_http_404 = \(cnd) NULL)
  
  if (!is.null(result)) {
    result %<>% httr2::resp_header(header = paste0("X-Gitlab-", heck::to_train_case(attribute)))
  }
  
  switch(EXPR = attribute,
         size = as.integer(result),
         execute_filemode = as.logical(result),
         result)
}

#' Read in file from GitLab repository
#'
#' Downloads a file from a GitLab repository via the
#' [`GET /projects/{id}/repository/files/{path}/raw`](https://docs.gitlab.com/ee/api/repository_files.html#get-raw-file-from-repository) endpoint of GitLab's v4
#' RESTful API and returns its content.
#'
#' @inheritParams file_req
#'
#' @return A character scalar if `path` refers to a text file, otherwise a raw vector.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_content(path = "DESCRIPTION",
#'                      id_proj = 64767928) |>
#'   cat()
file_content <- function(path,
                         id_proj,
                         ref = NULL,
                         base_url = pal::pkg_config_val("base_url"),
                         token = pal::pkg_config_val("token"),
                         max_tries = 3L) {
  result <-
    file_req(method = "GET",
             path = path,
             id_proj = id_proj,
             ref = ref,
             base_url = base_url,
             token = token,
             max_tries = max_tries) |>
    httr2::req_url_path_append("raw") |>
    httr2::req_perform()
  
  if (httr2::resp_content_type(result) == "text/plain") {
    result %<>% httr2::resp_body_string()
  } else {
    result %<>% httr2::resp_body_raw()
  }
  
  result
}

#' GitLab file data
#'
#' Retrieves a file's metadata and content as structured data via the
#' [`GET /projects/{id}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository) endpoint of GitLab's v4
#' RESTful API.
#'
#' Note that it is more efficient to use
#' - [file_content()] to only retrieve a file's content.
#' - [file_meta()] to only retrieve a single metadata entry.
#'
#' @inheritParams file_req
#'
#' @return A list.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_full(path = "DESCRIPTION",
#'                   id_proj = 64767928)
file_full <- function(path,
                      id_proj,
                      ref = NULL,
                      base_url = pal::pkg_config_val("base_url"),
                      token = pal::pkg_config_val("token"),
                      max_tries = 3L) {
  
  file_req(method = "GET",
           path = path,
           id_proj = id_proj,
           ref = ref,
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}

#' Write file to GitLab repository
#'
#' Uploads a file to a GitLab repository via [GitLab's v4 RESTful API](https://docs.gitlab.com/ee/api/rest/). High-level function that by default skips
#' uploading identical file content and automatically choses [file_create()] or [file_update()] based on whether the file already exists or not.
#'
#' To save up to two additional `HEAD` requests, set `start_branch` and `last_commit_id` explicitly. Setting `last_commit_id = NULL` is fine as long as file
#' writes are part of a controlled, single-user process where concurrency is not a concern.
#'
#' @inheritParams file_req
#' @param content `r pkgsnip::type("chr", length = 1L, add_cr = FALSE)` or `r pkgsnip::type("raw")`
#'   File content, as a character scalar for text files, or a raw vector for binary files. Or the path to a local file as a character scalar if
#'   `from_file = TRUE`.
#' @param start_branch `r pkgsnip::type("chr", 1L)`
#'   Name of the base branch to create `branch` from if it doesn't already exist.
#' @param branch `r pkgsnip::type("chr", 1L)`
#'   Git branch name to upload the file to.
#' @param from_file `r pkgsnip::type("lgl", 1L)`
#'   Whether or not `content` indicates the path to a local file instead of the actual file content.
#' @param overwrite `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to overwrite an already existing file. Unless `force = TRUE`, the file is only overwritten if it is not identical to `content`.
#' @param force `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to overwrite an already existing file even if it is identical to `content`.
#' @param commit_message `r pkgsnip::type("chr", 1L)`
#'   Git commit message.
#' @param author_email `r pkgsnip::type("chr", 1L)`
#'   Git commit author's email address. `NULL` means to default to the `token` owner.
#' @param author_name `r pkgsnip::type("chr", 1L)`
#'   Git commit author's name. `NULL` means to default to the `token` owner.
#' @param execute_filemode `r pkgsnip::type("lgl", 1L)`
#'   Whether or not to mark the uploaded file as executable,
#' @param last_commit_id `r pkgsnip::type("chr", 1L)`
#'   Last known file commit identifier. If provided (and valid), GitLab won't write to the file if a commit made after `last_commit_id` has modified the file.
#'   Intended to avoid concurrency issues (e.g. from CI pipelines). `NULL` means to skip the check.
#' @param quiet `r pkgsnip::type("lgl", 1L)`
#'   `r pkgsnip::param_lbl("quiet")`
#'
#' @return `path`, invisibly.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_write(content = "a line of text",
#'                    path = "test.md",
#'                    id_proj = 64767928)}
file_write <- function(content,
                       path,
                       id_proj,
                       start_branch = project_default_branch(id_proj = id_proj,
                                                             base_url = base_url,
                                                             token = token,
                                                             max_tries = max_tries),
                       branch = start_branch,
                       from_file = FALSE,
                       overwrite = TRUE,
                       force = FALSE,
                       commit_message = "auto: write file via gitlab R pkg",
                       author_email = NULL,
                       author_name = NULL,
                       execute_filemode = FALSE,
                       last_commit_id = file_meta(path = path,
                                                  attribute = "last_commit_id",
                                                  id_proj = id_proj,
                                                  ref = branch,
                                                  base_url = base_url,
                                                  token = token,
                                                  max_tries = max_tries),
                       base_url = pal::pkg_config_val("base_url"),
                       token = pal::pkg_config_val("token"),
                       max_tries = 3L,
                       quiet = FALSE) {
  
  checkmate::assert_flag(from_file)
  checkmate::assert_flag(overwrite)
  checkmate::assert_flag(force)
  checkmate::assert_flag(quiet)
  
  if (force && !overwrite) {
    cli::cli_abort("{.arg overwrite} cannot be {.val FALSE} when {.arg force} is {.val TRUE}.")
  }
  
  is_raw <- is.raw(content)
  
  if (is_raw && from_file) {
    cli::cli_abort("{.arg content} must be a character scalar path when {.arg from_file} is {.val {from_file}}.")
  }
  if (!is_raw) {
    checkmate::assert_string(content)
  }
  
  # return early if file hasn't changed ----
  exists_file <- file_exists(path = path,
                             id_proj = id_proj,
                             ref = branch,
                             base_url = base_url,
                             token = token,
                             max_tries = max_tries)
  if (!force && exists_file) {
    hash_new <- ifelse(from_file,
                       digest::digest(algo = "sha256",
                                      file = content),
                       digest::digest(algo = "sha256",
                                      object = content,
                                      serialize = FALSE))
    if (!force && identical(hash_new,
                            file_meta(path = path,
                                      attribute = "content_sha256",
                                      id_proj = id_proj,
                                      ref = branch,
                                      base_url = base_url,
                                      token = token,
                                      max_tries = max_tries))) {
      if (!quiet) {
        cli::cli_alert_info(paste0("The new file contents are identical to the existing file contents and thus no data was uploaded to the GitLab repository. ",
                                   "Use {.code force = TRUE} to overwrite the file anyway."))
      }
      return(invisible(path))
    }
  }
  
  # read content and set encoding ----
  if (from_file) {
    content %<>% brio::read_file_raw()
    is_raw <- TRUE
  }
  
  if (is_raw) {
    content %<>% base64enc::base64encode()
  }
  
  encoding = ifelse(is_raw,
                    "base64",
                    "text")
  # upload file ----
  if (!quiet) {
    link <- build_url(id_proj = id_proj,
                      path,
                      ref = branch,
                      force_branch_ref = TRUE,
                      base_url = base_url,
                      token = token,
                      max_tries = max_tries)
    cli_id <- pal::cli_progress_step_quick(msg = paste0("Uploading file to GitLab project {.val {id_proj}} under path {.href [{path}]({link})}."))
  }
  
  if (exists_file) {
    if (overwrite) {
      file_update(content = content,
                  path = path,
                  id_proj = id_proj,
                  branch = branch,
                  commit_message = commit_message,
                  author_email = author_email,
                  author_name = author_name,
                  encoding = encoding,
                  execute_filemode = execute_filemode,
                  last_commit_id = last_commit_id,
                  start_branch = start_branch,
                  base_url = base_url,
                  token = token,
                  max_tries = max_tries)
    } else {
      link <- build_url(id_proj = id_proj,
                        path,
                        ref = branch,
                        force_branch_ref = TRUE,
                        base_url = base_url,
                        token = token,
                        max_tries = max_tries)
      cli::cli_alert_info(text = "File {.href [{path}]({link})} already exists on GitLab. Set {.code overwrite = TRUE} in order to overwrite it.")
    }
  } else {
    file_create(content = content,
                path = path,
                id_proj = id_proj,
                branch = branch,
                commit_message = commit_message,
                author_email = author_email,
                author_name = author_name,
                encoding = encoding,
                execute_filemode = execute_filemode,
                start_branch = start_branch,
                base_url = base_url,
                token = token,
                max_tries = max_tries)
  }
  
  if (!quiet) {
    cli::cli_progress_done(id = cli_id)
  }
  
  invisible(path)
}

#' Create file in GitLab repository
#'
#' Creates a new file in a GitLab repository via the
#' [`POST /projects/{id}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository) endpoint of GitLab's v4
#' RESTful API.
#'
#' @inheritParams file_update
#'
#' @return A list with metadata about the newly created file.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_create(content = "a line of text",
#'                     path = "test.md",
#'                     id_proj = 64767928)}
file_create <- function(content,
                        path,
                        id_proj,
                        start_branch = project_default_branch(id_proj = id_proj,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: create file via gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        encoding = c("text", "base64"),
                        execute_filemode = FALSE,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(content)
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  encoding <- rlang::arg_match(encoding)
  checkmate::assert_flag(execute_filemode)
  
  file_req(method = "POST",
           path = path,
           id_proj = id_proj,
           body_json = purrr::compact(list(branch = branch,
                                           content = content,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           encoding = encoding,
                                           execute_filemode = execute_filemode,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}

#' Update file in GitLab repository
#'
#' Updates an existing file in a GitLab repository via the
#' [`PUT /projects/{id}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository) endpoint of GitLab's
#' v4 RESTful API.
#'
#' @inheritParams file_write
#' @param encoding `r pkgsnip::type("chr", 1L)`
#'   File encoding. One of `r pal::enum_fn_param_defaults(param = "encoding", fn = file_update)`.
#'
#' @inherit file_create return
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_update(content = "a different line of text",
#'                     path = "test.md",
#'                     id_proj = 64767928)}
file_update <- function(content,
                        path,
                        id_proj,
                        start_branch = project_default_branch(id_proj = id_proj,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: update file gitlab gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        encoding = c("text", "base64"),
                        execute_filemode = FALSE,
                        last_commit_id = NULL,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(content)
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  encoding <- rlang::arg_match(encoding)
  checkmate::assert_flag(execute_filemode)
  checkmate::assert_string(last_commit_id,
                           null.ok = TRUE)
  
  file_req(method = "PUT",
           path = path,
           id_proj = id_proj,
           body_json = purrr::compact(list(branch = branch,
                                           content = content,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           encoding = encoding,
                                           execute_filemode = execute_filemode,
                                           last_commit_id = last_commit_id,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
}

#' Delete file from GitLab repository
#'
#' Deletes a file from a GitLab repository via the
#' [`DELETE /projects/{id}/repository/files/{path}`](https://docs.gitlab.com/ee/api/repository_files.html#delete-existing-file-in-repository) endpoint of
#' GitLab's v4 RESTful API.
#'
#' @inheritParams file_write
#'
#' @return `path`, invisibly.
#' @family files
#' @export
#'
#' @examples
#' \dontrun{
#' gitlab::file_delete(path = "test.md",
#'                     id_proj = 64767928)}
file_delete <- function(path,
                        id_proj,
                        start_branch = project_default_branch(id_proj = id_proj,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries),
                        branch = start_branch,
                        commit_message = "auto: delete file via gitlab R pkg",
                        author_email = NULL,
                        author_name = NULL,
                        last_commit_id = NULL,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  checkmate::assert_string(start_branch,
                           null.ok = TRUE)
  checkmate::assert_string(branch)
  checkmate::assert_string(commit_message)
  checkmate::assert_string(author_email,
                           null.ok = TRUE)
  checkmate::assert_string(author_name,
                           null.ok = TRUE)
  checkmate::assert_string(last_commit_id,
                           null.ok = TRUE)
  
  file_req(method = "DELETE",
           path = path,
           id_proj = id_proj,
           body_json = purrr::compact(list(branch = branch,
                                           commit_message = commit_message,
                                           author_email = author_email,
                                           author_name = author_name,
                                           start_branch = start_branch)),
           base_url = base_url,
           token = token,
           max_tries = max_tries) |>
    httr2::req_perform()
  
  invisible(path)
}

#' Test if file exists in GitLab repository
#'
#' Tests whether or not a file exists in a GitLab repository.
#' 
#' `file_exists()` makes a light-weight HTTP HEAD request only and properly handles HTTP 404 Not Found errors.
#'
#' @inheritParams file_req
#'
#' @return A logical scalar.
#' @family files
#' @export
#'
#' @examples
#' gitlab::file_exists(path = "README.md",
#'                     id_proj = 64767928)
#'
#' gitlab::file_exists(path = "test.md",
#'                     id_proj = 64767928)
file_exists <- function(path,
                        id_proj,
                        ref = NULL,
                        base_url = pal::pkg_config_val("base_url"),
                        token = pal::pkg_config_val("token"),
                        max_tries = 3L) {
  
  result <- tryCatch(expr = httr2::req_perform(req = file_req(method = "HEAD",
                                                              path = path,
                                                              id_proj = id_proj,
                                                              ref = ref,
                                                              base_url = base_url,
                                                              token = token,
                                                              max_tries = max_tries)),
                     httr2_http_404 = \(cnd) FALSE)
  
  if (!isFALSE(result)) {
    result <- TRUE
  }
  
  result
}

utils::globalVariables(names = c("."))
